pkttools
製作：坂井弘亮 (KOZOSプロジェクト)

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
■ 概要

パケットキャプチャ＆送信などを行うテキストベースの簡易ツール群です．
各ツールはパイプで繋げて連携させることができます．
テキストベースなので，パケットをパッと見てみたりちょっと修正して再送信
したり，各種スクリプトを組み合わせて利用したりということが簡便にできます．

(重要！)
本ツールはネットワークの勉強・検証を目的として作成・配布するものです．
不用意な利用はネットワークに様々な影響を与えたり，様々な問題を引き起こす
可能性があるため，ツールの動作を理解した上で，ローカル環境で利用するか
ネットワーク管理者の許可を得た上で利用するようにしてください．勉強や検証を
目的として，正しいモラルのもとで利用してください． 

以下のツールがあります．

・簡易パケットキャプチャ
・簡易パケット送信
・pcapフォーマットとの変換 (Wiresharkと連携できます)
・簡易パケットアナライザ
・チェックサム再計算
・パケットフィルタ
・パケット変換
・ping応答ツール

FreeBSD/Linux両用です．
FreeBSD-8.4/CentOS6.5の環境でコンパイルと動作確認しています．

フリーソフトウェアです．ご自由にお使いください．
ただし無保証です．本ツールを利用することで発生した不具合や問題などについて，
作者は一切の責任を負いません．各自の責任の下で利用してください． 
ライセンスは KL-01 と LICENSE を参照してください．

作者の連絡先は以下です．バグ報告など歓迎します．
(ただし，必ず返信するとは限りません)
kozos[アットマーク]kozos.jp

■ ツール一覧

pkt-recv     ... パケットキャプチャして，受信データをテキスト出力
pkt-send     ... テキスト入力されたパケットを送信
pkt-txt2txt  ... テキスト入力されたパケットをテキストで再出力(テキストの整形用)
pkt-txt2pcap ... テキスト入力されたパケットをpcapフォーマットに変換
pkt-pcap2txt ... pcapフォーマットを解読してテキスト出力する
pkt-analyze  ... テキスト入力されたパケットを解析
pkt-correct  ... テキスト入力されたパケットのチェックサムを再計算して再出力
pkt-filter   ... テキスト入力されたパケットをフィルタして再出力(※１)
pkt-change   ... テキスト入力されたパケットを変換して再出力(※１)
pkt-pingrep  ... テキスト入力されたパケットからpingの応答パケットを出力する

※１ ルールをソースコードに直接記述してコンパイルしなおして利用する

■ パケットの出力の例

パケットを出力するツール(pkt-recvなど)は，以下のようなテキストフォーマットで
出力します．
パケットを入力するツール(pkt-sendなど)は，以下のようなテキストフォーマットの
入力を受け付けます．
(つまり，それらはパイプで連結して使えます)

user@letsnote:~/pkttools-0.9>% pkt-recv -i em0
-- 1 --
TIME: 1400167480.561500 Fri May 16 00:24:40 2014
SIZE: 98/98
000000: 00 11 22 33  44 55 00 AA  BB CC DD EE  08 00 45 00 : .."3DU.. ......E.
000010: 00 54 00 00  00 00 40 01  F7 55 C0 A8  01 01 C0 A8 : .T....@. .U......
000020: 01 02 08 00  4A 2F 03 0F  00 00 53 8A  C4 11 00 07 : ....J/.. ..S.....
000030: A8 1B 08 09  0A 0B 0C 0D  0E 0F 10 11  12 13 14 15 : ........ ........
000040: 16 17 18 19  1A 1B 1C 1D  1E 1F 20 21  22 23 24 25 : ........ .. !"#$%
000050: 26 27 28 29  2A 2B 2C 2D  2E 2F 30 31  32 33 34 35 : &'()*+,- ./012345
000060: 36 37                                              : 67
==
-- 2 --
TIME: 1400167480.561510 Fri May 16 00:24:40 2014
SIZE: 98/98
000000: 00 11 22 33  44 55 00 AA  BB CC DD EE  08 00 45 00 : .."3DU.. ......E.
000010: 00 54 00 00  00 00 40 01  F7 55 C0 A8  01 01 C0 A8 : .T....@. .U......
000020: 01 02 08 00  4A 2F 03 0F  00 00 53 8A  C4 11 00 07 : ....J/.. ..S.....
000030: A8 1B 08 09  0A 0B 0C 0D  0E 0F 10 11  12 13 14 15 : ........ ........
000040: 16 17 18 19  1A 1B 1C 1D  1E 1F 20 21  22 23 24 25 : ........ .. !"#$%
000050: 26 27 28 29  2A 2B 2C 2D  2E 2F 30 31  32 33 34 35 : &'()*+,- ./012345
000060: 36 37                                              : 67
==

「--」〜「==」でくくられている部分が，１個のパケットになります．
(上の例では２個のパケットが出力されています)
テキスト出力をいったん保存し，テキストエディタで特定のパケットのみ切り出したり
パケットを部分的に書き換えて，他のツールに印加することができます．

例えばpkt-recvで受信したデータをいったんテキストファイルとして保存し，
テキストエディタで特定のパケットのみ切り出して再度保存，pkt-sendで送信する
ことで，特定のパケットのみ繰り返し送信したりすることができます．
以下のような流れです．

% pkt-recv -i eth0 > capture.txt
^C  (適当な時間経過後に，Ctrl-Cで強制終了)
% vi capture.txt  (編集)
% cat capture.txt | pkt-send -i eth0  (送信)

pcapフォーマットと連携できます．例えばWiresharkでキャプチャしたパケットをpcap
で一旦保存，pkt-pcap2txt で上記テキストフォーマットに変換，変換したテキスト
ファイルをテキストエディタで修正，pkt-txt2pcap でpcapフォーマットに戻す，と
いったことができます．

% cat capture.pcap | pkt-pcap2txt > capture.txt
% vi capture.txt  (編集)
% cat capture.txt | pkt-txt2pcap > capture.pcap
% wireshark capture.pcap  (Wiresharkで参照)

他にもWiresharkのキャプチャ結果(capture.pcap)からUDPパケットのみ
取り出したい場合には，以下のようにできます．

% cat capture.pcap | pkt-pcap2txt IP.PROTOCOL==17 | pkt-txt2pcap > cap2.pcap
% wireshark cap2.pcap  (Wiresharkで参照)

このようにテキストエディタで扱ったり，パイプによるスクリプト処理がしやすい
ような作りになっています．

■ パケットのサンプル

各種のパケットのサンプルデータが，samplesというディレクトリに置かれています．

パケット自作などのサンプルに使えるかと思います．

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
■ 使いかた

■ コンパイル方法

解凍して make するだけです．(./configureは不要です)
FreeBSD/Linuxの両環境でコンパイル確認してあります．

■ 使うときの注意点

・FreeBSDの場合
  まず準備としてFreeBSDの場合は，スーパーユーザで以下をやっておきます．
  # chmod 666 /dev/bpf*

・Linuxの場合
  とくに準備はありませんが，pkt-recv / pkt-send はスーパーユーザで
  実行する必要があります．(RAWソケットを利用するため)

まず ifconfig コマンドにより，使用できるインターフェース一覧を参照します．
FreeBSDだと fxp0 とか em0 とか rl0 のようなのが使えます．
Linuxだと eth0, eth1, ... のようなのが使えます．

必要に応じて，インターフェースを有効化します．
(inconfigでインターフェースにUPフラグが立っていない場合には必要です)

# ifconfig em0 up

■ 使いかたの例

以下は Linux で eth0 を使う場合の例です．

・パケットの受信

  % pkt-recv -i eth0

・パケットをキャプチャして解析して表示

  % pkt-recv -i eth0 | pkt-analyze

・パケットをキャプチャして各フィールド値を表示

  % pkt-recv -i eth0 -a

・eth0 → eth1 にパケットをブリッジする

  % pkt-recv -i eth0 | pkt-send -i eth1

・IPパケットのみブリッジ

  % pkt-recv -i eth0 ETHERNET.TYPE==0x0800 | pkt-send -i eth1

・宛先が192.168.1.Xのパケットのみブリッジ

  % pkt-recv -i eth0 "IP.DST_ADDR>=192.168.1.0" \
            | pkt-txt2txt "IP.DST_ADDR<=192.168.1.255" | pkt-send -i eth1

・TTL値を書き換えてチェックサム再計算してブリッジ

  % pkt-recv -i eth0 IP.TTL=0xFF | pkt-correct | pkt-send -i eth1

・eth0 ←→ eth1 の間を双方向にブリッジする (簡易ブリッジ)

  % (pkt-recv -i eth0 -ro | pkt-send -i eth1) &
  % (pkt-recv -i eth1 -ro | pkt-send -i eth0) &

・パケットを一旦保存し解析．さらに別インターフェースに強制送信

  % pkt-recv -i eth0 > capture.txt
  % cat capture.txt | pkt-analyze
  % cat capture.txt | pkt-send -i eth1

・パケットをpcapフォーマットで保存し，あとで Wireshark で開く

  % pkt-recv -i eth0 | pkt-txt2pcap > capture.pcap
  % wireshark capture.pcap

・Wiresharkでキャプチャし保存したパケット(capture.pcap)をeth0に強制送信

  % cat capture.pcap | pkt-pcap2txt | pkt-send -i eth0

・キャプチャしたパケットを改造してチェックサムを再計算し再送信

  % pkt-recv -i eth0 > capture.txt
  % vi capture.txt
  % cat capture.txt | pkt-correct | pkt-send -i eth0

・受信したARPとICMP Echoにすべて応答する(あらゆるpingに応答します)

  % pkt-recv -i eth0 -ro | pkt-pingrep | pkt-send -i eth0

■ 各種オプション

共通

  -b <size>	バッファサイズを指定
		(pkt-recvは標準では自動設定，それ以外は標準では80KB)
  -a		各フィールドの値を出力
  -r		フィルタ判定を反転する
		(マッチしたもののみ通過 → マッチしたもののみ遮断)

pkt-recv

  -i <ifname>	受信インターフェースを指定する
  -l <count>	指定した数のパケットを受信したら終了する
  -np		プロミスキャスモードにしない (標準ではプロミスキャスモード)
  -ro		自分が送信したパケットは受信しない (標準では双方向受信)

pkt-send

  -i <ifname>	送信インターフェースを指定する
  -w <microsec>	送信時にウェイトを入れる (-fでの送信が速すぎる際に利用できる)
  -c		送信元MACアドレスを，自身のMACアドレスで自動補完して送信する
  -f		パケットの時刻を見ずに連続で送信する
		(標準では受信時刻の差分を見て，受信時と同じ間隔で送信する)
  -j		パケット送信時の時刻を，直前のパケットに対して計算する
		(標準では最初のパケット送信の時刻に対して計算する)
		(このオプションを利用すると，誤差が積み重なっていく可能性あり)

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
■ テキストデータの書式について

■ パケットデータはテキストで扱われます

パケットデータは以下のようなテキスト形式で扱われます．
以下は pkt-recv で受信したパケットを，pkt-send で別のインターフェースに
送信してみる例です．

user@letsnote:~/pkttools-1.0>% pkt-recv -i rl0 -l 1 > capture.txt (rl0で受信)
user@letsnote:~/pkttools-1.0>% cat capture.txt
-- 1 --
TIME: 1400296569.633895 Sat May 17 12:16:09 2014
SIZE: 98/98
000000: 00 11 22 33  44 55 00 AA  BB CC DD EE  08 00 45 00 : ..gQ.... ......E.
000010: 00 54 59 86  00 00 40 01  9D C4 C0 A8  01 0D C0 A8 : .TY...@. ........
000020: 01 01 08 00  D2 DA 66 11  00 00 53 76  D4 79 00 09 : ......f. ..Sv.y..
000030: AC 17 08 09  0A 0B 0C 0D  0E 0F 10 11  12 13 14 15 : ........ ........
000040: 16 17 18 19  1A 1B 1C 1D  1E 1F 20 21  22 23 24 25 : ........ .. !"#$%
000050: 26 27 28 29  2A 2B 2C 2D  2E 2F 30 31  32 33 34 35 : &'()*+,- ./012345
000060: 36 37                                              : 67
==
user@letsnote:~/pkttools-1.0>% cat capture | pkt-send -i rl1  (rl1に送信)

capture.txtをテキストエディタで適当にデータを書き換えて送信することができます．
つまり，パケットの内容を適当に書き換えて送信することができます．
(データを書き換えることでIPやUDPのチェックサムが変わってしまう場合は，
pkt-correct を通すことでチェックサムが再計算され再設定されます)

■ テキストデータのフォーマット

まずテキストデータ中では，「--」と「==」で囲まれている部分を１つのパケット
データとして扱います．

上記の例では出力時に「-- 1 --」のようにパケットの番号が付加されていますが，
番号は無視されるので適当で構いませんし，「--」のように省略しても構いません．

テキストデータの右側にはASCII文字がありますが，データを書き換える場合，
ASCII文字部分はデータに合わせて書き換える必要はありません．
(ASCII文字部分は無視されますので，そもそも削ってしまっても構いません)

また「TIME:」や「SIZE:」の表記は省略できます．
さらにデータは１行に16個でなくても構いません．

例えば，以下のようなテキストデータを pkt-send に与えても問題なく解釈されて
出力されます．
(上のcapture.txtと等価になります．なお先頭の「--」と終端の「==」は必要です)

--
00 11 22 33 44 55 00 AA BB CC DD EE 08 00 45 00  00 54 59 86 00 00 40 01 9D C4 C0 A8 01 0D C0 A8
01 01 08 00 D2 DA 66 11 00 00 53 76 D4 79 00 09  AC 17 08 09 0A 0B 0C 0D 0E 0F 10 11 12 13 14 15
16 17 18 19 1A 1B 1C 1D 1E 1F 20 21 22 23 24 25  26 27 28 29 2A 2B 2C 2D 2E 2F 30 31 32 33 34 35  36 37
==

もちろん上記データは，pkt-send 以外の pkt-analyze や pkt-txt2pcap に与えても
問題なく解釈されます．(テキストデータの入出力には，同じ処理を利用しています)

■ テキストデータの整形

テキストデータは pkt-txt2txt を通すことで整形されます．
実際にどのようなデータが出力されるのかを確認したい場合には
pkt-txt2txtを通してみるといいでしょう．

user@letsnote:~/pkttools-1.0>% cat capture2.txt
--
00 11 22 33 44 55 00 AA BB CC DD EE 08 00 45 00  00 54 59 86 00 00 40 01 9D C4 C0 A8 01 0D C0 A8
01 01 08 00 D2 DA 66 11 00 00 53 76 D4 79 00 09  AC 17 08 09 0A 0B 0C 0D 0E 0F 10 11 12 13 14 15
16 17 18 19 1A 1B 1C 1D 1E 1F 20 21 22 23 24 25  26 27 28 29 2A 2B 2C 2D 2E 2F 30 31 32 33 34 35  36 37
==
user@letsnote:~/pkttools-1.0>% cat capture2.txt | pkt-txt2txt
-- 1 --
TIME: 0.0 Thu Jan  1 09:00:00 1970
SIZE: 98/98
000000: 00 11 22 33  44 55 00 AA  BB CC DD EE  08 00 45 00 : .."3DU.. ......E.
000010: 00 54 59 86  00 00 40 01  9D C4 C0 A8  01 0D C0 A8 : .TY...@. ........
000020: 01 01 08 00  D2 DA 66 11  00 00 53 76  D4 79 00 09 : ......f. ..Sv.y..
000030: AC 17 08 09  0A 0B 0C 0D  0E 0F 10 11  12 13 14 15 : ........ ........
000040: 16 17 18 19  1A 1B 1C 1D  1E 1F 20 21  22 23 24 25 : ........ .. !"#$%
000050: 26 27 28 29  2A 2B 2C 2D  2E 2F 30 31  32 33 34 35 : &'()*+,- ./012345
000060: 36 37                                              : 67               
==
user@letsnote:~/pkttools-1.0>% 

■ テキストデータの表記の詳細

以下，データの表記方法の詳細です．

・TIME: の指定について

  ＊省略できます．省略すると 0.0 を指定したことになります．
  ＊「Sat May 17 12:16:09 2014」のような日付表示は省略できます．(無視されます)
  ＊書式は「TIME: <秒>.<マイクロ秒>」です．
    「100」や「100.」は「100.0」と同義です．「.100」は「0.100」と同義です．
  ＊pkt-sendによる送信時には，TIME: で指定された時刻に送信間隔を合わせて
    送信されます．0.0 の場合には即時送信します．

・SIZE: の指定について

  ＊省略できます．省略するとデータ数から自動計算されます．
  ＊書式は「SIZE: <キャプチャ量>/<オリジナルのデータ量>」です．
    「100」は「100/100」と同義，「100/」は「100/0」と同義になります．
  ＊SIZE:によるサイズ指定とデータ数が異なる場合はSIZE:によるサイズ指定が
    優先され，以下のようになります．
    「サイズ指定＜データ数」の場合 ... サイズを超えたデータは無視されます．
    「サイズ指定＞データ数」の場合 ... 足りないデータはゼロで埋められます．

・データの表記について

  ＊「000000: 00 11 22 33」のような表記は，先頭の「000000:」(オフセット表記)
    は無視され，その後の「00 11...」をデータとして扱います．
  ＊「00 11 22 33」のような表記は，そのままデータとして扱います．
  ＊オフセット表記がある場合，オフセットのとおりにデータを読むのではなく，
    オフセット表記は無視されます．
  ＊例えば以下のようにオフセット表記が逆転している場合にも，
    読まれるデータは「00 11 22 33 44 55 66 77」のような順番
    (データの表記順)になります．

    000004: 00 11 22 33
    000000: 44 55 66 77

  ＊データ表記は「ab」のように小文字でも「AB」のように大文字でも構いません．
  ＊データ表記は２桁が基本ですが，１桁で書くこともできます．
    例えば「A」は「0A」と等価です．
  ＊データを２桁以上で書いた場合，下２桁が読み込まれます．
    つまり「ABCD」と書いた場合には，実際のデータは「CD」になります．
  ＊右端のASCII文字は無視されます．(「:」以降はコメントとして無視されます)

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
■ パケットフィルタとパケット変換 (簡易版)

簡易フィルタ・簡易パケット変換の機能があります．
全てのツールで共通で利用できます．

■ 簡易フィルタの方法

オプションで以下のようにフィルタ条件を指定することで，簡易フィルタを
かけられます．(複雑な条件は指定できません．複雑なフィルタをかけたい場合は
pkt-filter を利用してください)

全てのツールで利用できます．(pkt-analyze, pkt-send などでも利用可能)

pkt-recv -i eth0 ETHERNET.TYPE==0x0806 ... ARPのみ通過
pkt-recv -i eth0 ETHERNET.TYPE==0x0800 ... IPのみ通過
pkt-recv -i eth0 ETHERNET.TYPE==0x86DD ... IPv6のみ通過

pkt-recv -i eth0 IP.PROTOCOL==1  ... ICMPのみ通過
pkt-recv -i eth0 IP.PROTOCOL==6  ... TCPのみ通過
pkt-recv -i eth0 IP.PROTOCOL==17 ... UDPのみ通過

指定できる条件は以下です．
('<'や'>'が入る場合，リダイレクションと間違えないように""でくくります)

pkt-recv -i eth0 UDP.DST_PORT==80   ... UDPで80番ポートのみ通過
pkt-recv -i eth0 UDP.DST_PORT!=80   ... UDPで80番ポート以外を通過
pkt-recv -i eth0 "UDP.DST_PORT<80"  ... UDPで80番ポート未満を通過
pkt-recv -i eth0 "UDP.DST_PORT>80"  ... UDPで80番ポートより上を通過
pkt-recv -i eth0 "UDP.DST_PORT<=80" ... UDPで80番ポート以下を通過
pkt-recv -i eth0 "UDP.DST_PORT>=80" ... UDPで80番ポート以上を通過

各フィールド指定のキーワード(上記の「UDP.DST_PORT」とか)はソースコードの
asm_field.c を参照するか，各ツールを -a オプション付きで実行して
フィールド値を出力させてみてください．

MACアドレス，IPアドレス，IPv6アドレス，文字列も同様の演算子で比較できます．

pkt-recv -i eth0 IP.SRC_ADDR==192.168.1.1 ... IPアドレスが192.168.1.1を通過

pkt-recv -i eth0 "IP.DST_ADDR>=192.168.1.0" \
        | pkt-txt2txt "IP.DST_ADDR<=192.168.1.255"
 ... IPアドレスが192.168.1.Xの場合に通過

フィルタ条件を複数記述した場合には，OR論理になります．

pkt-recv -i eth0 UDP.SRC_PORT==80 UDP.DST_PORT==80
  ... 送信元と宛先のいずれかが80番ポートの場合に通過

AND論理でフィルタをかけたい場合には，以下のようにツールを２重に通過させて
ください．

pkt-recv -i eth0 UDP.SRC_PORT==80 | pkt-txt2txt IP.SRC_ADDR==192.168.1.1

デフォルトではフィルタ条件を記述すると，マッチしたもののみ通過になります．
-r を付加すると判断が逆転します．

pkt-recv -i eth0 -r UDP.DST_PORT==80 ... UDPの80番ポートを遮断

以下のようになります．

pkt-recv -i eth0 UDP.DST_PORT==80    ... UDP80番ポートを通過，UDP以外は遮断
pkt-recv -i eth0 UDP.DST_PORT!=80    ... UDP80番ポート以外を通過，UDP以外は遮断
pkt-recv -i eth0 -r UDP.DST_PORT==80 ... UDP80番ポートを遮断，UDP以外は通過
pkt-recv -i eth0 -r UDP.DST_PORT!=80 ... UDP80番ポート以外を遮断，UDP以外は通過

■ 簡易パケット変換の方法

以下のようにオプション指定することで，フィールド値の書き換えを行うことが
できます．(複雑な書き換えはできません．複雑な書き換えをしたい場合は
pkt-change を利用してください)

全てのツールで利用できます．(pkt-analyze, pkt-send などでも利用可能)

pkt-recv -i eth0 UDP.DST_PORT=80 ... UDPの宛先ポート番号を80に変換して出力

数値は10進でも16進でも指定可能です．16進の場合は0xを付加してください．

MACアドレス，IPアドレス，IPv6アドレス，文字列も指定できます．

パケットの内容が変換された際，チェックサムの再計算が必要になる場合があります．
必要ならば pkt-correct を通すことで再計算・再設定してくれます．

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
■ パケット変換 (スクリプトとの組み合わせ)

■ フィールド値を指定して変換する

テキスト出力の中でフィールド値の書き換えを指定することができます．
例えば以下のような出力があるとします．

-- 1 --
TIME: 0.000000 Thu Jan  1 09:00:00 1970
SIZE: 98/98
000000: 00 11 22 33  44 55 00 AA  BB CC DD EE  08 00 45 00 : .."3DU.. ......E.
000010: 00 54 00 00  00 00 40 01  F7 55 C0 A8  01 01 C0 A8 : .T....@. .U......
000020: 01 02 08 00  4A 2F 03 0F  00 00 53 8A  C4 11 00 07 : ....J/.. ..S.....
000030: A8 1B 08 09  0A 0B 0C 0D  0E 0F 10 11  12 13 14 15 : ........ ........
000040: 16 17 18 19  1A 1B 1C 1D  1E 1F 20 21  22 23 24 25 : ........ .. !"#$%
000050: 26 27 28 29  2A 2B 2C 2D  2E 2F 30 31  32 33 34 35 : &'()*+,- ./012345
000060: 36 37                                              : 67
==

ここで，IP.TTLの値の指定を追加します．

-- 1 --
TIME: 0.000000 Thu Jan  1 09:00:00 1970
SIZE: 98/98
000000: 00 11 22 33  44 55 00 AA  BB CC DD EE  08 00 45 00 : .."3DU.. ......E.
000010: 00 54 00 00  00 00 40 01  F7 55 C0 A8  01 01 C0 A8 : .T....@. .U......
000020: 01 02 08 00  4A 2F 03 0F  00 00 53 8A  C4 11 00 07 : ....J/.. ..S.....
000030: A8 1B 08 09  0A 0B 0C 0D  0E 0F 10 11  12 13 14 15 : ........ ........
000040: 16 17 18 19  1A 1B 1C 1D  1E 1F 20 21  22 23 24 25 : ........ .. !"#$%
000050: 26 27 28 29  2A 2B 2C 2D  2E 2F 30 31  32 33 34 35 : &'()*+,- ./012345
000060: 36 37                                              : 67
IP.TTL: 0xFF    (TTLの指定を末尾に追加した)
==

上記 IP.TTL を追加したテキストをツールに流し込むと，TTL値を0xFFに変換した上で
処理を行います．(全ツール共通です)
ちょっとしたデータ変換を行ったり，スクリプトで処理したりするときに便利です．
(必要ならば pkt-correct を通すことでチェックサムを再設定できます)

■ フィールド値を出力させる

各ツールは -a オプションを付加して実行すると，バイトデータに続いて各フィールド
の値を出力します．以下のような感じです．

% cat packet.txt
-- 1 --
TIME: 0.000000 Thu Jan  1 09:00:00 1970
SIZE: 98/98
000000: 00 11 22 33  44 55 00 AA  BB CC DD EE  08 00 45 00 : .."3DU.. ......E.
000010: 00 54 00 00  00 00 40 01  F7 55 C0 A8  01 01 C0 A8 : .T....@. .U......
000020: 01 02 08 00  4A 2F 03 0F  00 00 53 8A  C4 11 00 07 : ....J/.. ..S.....
000030: A8 1B 08 09  0A 0B 0C 0D  0E 0F 10 11  12 13 14 15 : ........ ........
000040: 16 17 18 19  1A 1B 1C 1D  1E 1F 20 21  22 23 24 25 : ........ .. !"#$%
000050: 26 27 28 29  2A 2B 2C 2D  2E 2F 30 31  32 33 34 35 : &'()*+,- ./012345
000060: 36 37                                              : 67
==
% cat packet.txt | pkt-txt2txt -a
-- 1 --
TIME: 0.000000 Thu Jan  1 09:00:00 1970
SIZE: 98/98
000000: 00 11 22 33  44 55 00 AA  BB CC DD EE  08 00 45 00 : .."3DU.. ......E.
000010: 00 54 00 00  00 00 40 01  F7 55 C0 A8  01 01 C0 A8 : .T....@. .U......
000020: 01 02 08 00  4A 2F 03 0F  00 00 53 8A  C4 11 00 07 : ....J/.. ..S.....
000030: A8 1B 08 09  0A 0B 0C 0D  0E 0F 10 11  12 13 14 15 : ........ ........
000040: 16 17 18 19  1A 1B 1C 1D  1E 1F 20 21  22 23 24 25 : ........ .. !"#$%
000050: 26 27 28 29  2A 2B 2C 2D  2E 2F 30 31  32 33 34 35 : &'()*+,- ./012345
000060: 36 37                                              : 67
ETHERNET.DST_ADDR:      00:11:22:33:44:55
ETHERNET.SRC_ADDR:      00:aa:bb:cc:dd:ee
ETHERNET.TYPE:          0x800
IP.VERSION:             0x4
IP.HEADER_SIZE:         0x14
IP.TOS:                 0x0
IP.TOTAL_SIZE:          0x54
IP.ID:                  0x0
IP.FRAGMENT:            0x0
IP.TTL:                 0x40
IP.PROTOCOL:            0x1
IP.CHECKSUM:            0xf755
IP.SRC_ADDR:            192.168.1.1
IP.DST_ADDR:            192.168.1.2
ICMP.TYPE:              0x8
ICMP.CODE:              0x0
ICMP.CHECKSUM:          0x4a2f
==

「IP.ID」や「IP.TTL」のようにして，プロトコルの各フィールドの値が出力されて
います．

■ スクリプトと組み合わせてフィールド値を書き換える

ここで例えばIP.TTLを以下のように書き換えて他のツールに入力すると，当該の
フィールドの値を書き換えてデータを扱います．
(すべてのフィールドを記述する必要はありません．記述があるフィールドのみ
値の変換を行います)

IP.TTL:                 0x40
↓
IP.TTL:                 0xFF

これはスクリプトでの処理に向いています．例えば以下のようにPerlと組み合わせる
ことで，TTLを0xFFに変換して転送することができます．
(チェックサム再計算の必要があるため，変換後に pkt-correct を通しています)

pkt-recv -i eth0 -a | perl -pe 's/IP\.TTL:.*/IP\.TTL: 0xFF/' \
        | pkt-correct | pkt-send -i eth1

＃ もちろんこれは，以下のようにして簡易パケット変換でも実現可能です．
＃ が，スクリプトで細かい変換制御など行いたい場合は，上のようにPerlなどと
＃ 組み合わせることが有用でしょう．
＃ pkt-recv -i eth0 IP.TTL=0xFF | pkt-correct | pkt-send -i eth1

フィールド値が複数指定されている場合には，後のほうの指定が有効になります．
このため「==」の直前にフィールド値指定の行を追加することで，フィールド値を
上書きできます．これもスクリプトでの処理がやりやすいと思います．

■ 簡易フィルタ・簡易パケット変換・フィールド値指定などの動作について

簡易フィルタと簡易パケット変換の処理の順番は，以下のようになっています．
以下の動作はpkttoolsのすべてのツールに共通です．

１．入力を行う．テキスト入力の場合，まずバイトデータを読み込み，さらに
    フィールド値の指定がある場合にはその値に変換する．フィールド値の指定が
    無い場合はそのまま．

２．実行時オプションで簡易フィルタが指定されている場合には，適用する．

３．行うべき処理がある場合には，当該の処理を行う．
    (たとえば pkt-correct ではチェックサム計算など)

４．実行時オプションで簡易パケット変換が指定されている場合には，変換を行う．

５．出力を行う．テキスト出力の場合，-a オプションが付加されているならば
    各フィールドの値も出力する．

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
■ パケットフィルタとパケット変換 (複雑なものを行いたい場合)

■ pkt-filter/pkt-change によるパケットフィルタ／パケット変換

前述の簡易フィルタ／簡易パケット変換で実現できないような複雑なフィルタや
パケット変換を行うためのテンプレートとして，pkt-filter/pkt-change があります．

pkt-filter / pkt-change はそのままで使っても，意味はありません．

pkt-filter / pkt-change は，あくまで自前のフィルタ／交換プログラムを作るための
テンプレートとなっています．

パケットフィルタやパケット変換を行いたい場合は，まず filter.c / change.c の
ソースコードを直接書き換えて，期待のフィルタ／変換動作をするようにして
ください．ソースコードはさほど難しくは無く，テンプレート的に書いてあるので，
修正はそれほど難しくはないかと思います．

で，make して pkt-filter / pkt-change の実行ファイルを再生成することで，
期待の動作をするパケットフィルタ／パケット変換として利用することができます．

  % vi filter.c  (filter.cを直接修正することでフィルタ条件を任意に設定する)
  % vi change.c  (change.cを直接修正することで変換ルールを任意に設定する)
  % make    (再コンパイルすることで，希望の動作の pkt-filter/pkt-change を生成)
  % pkt-recv -i eth0 | pkt-filter | pkt-analyze      (フィルタ処理の例)
  % pkt-recv -i eth0 | pkt-change | pkt-correct | pkt-send -i eth1 (変換の例)

パケットフィルタやパケット変換を独自ルールや独自言語でやろうとすると
どうしても複雑になる割にはたいしたことは行えず記述方法をマスターする
だけでも面倒で，だったらそもそもＣ言語のソースコードを直接書き換えたほうが
いいんじゃね？ という判断でこのようにしています．

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
■ 利用の実践例

■ スクリプトと組み合わせて，パケットを自動生成＆送信してみる

例えば以下は，UDPのパケットのサンプルデータです．
適当なUDPパケットを送信して pkt-recv でキャプチャした内容を，
適当に修正したものです．

-- 1 --
TIME: 0.0 Thu Jan  1 09:00:00 1970
SIZE: 60/60
000000: 00 11 22 33  44 55 00 AA  BB CC DD EE  08 00 45 00 : .."3DU.. ......E.
000010: 00 2E 00 01  00 00 40 11  F7 6A C0 A8  01 02 C0 A8 : ......@. .j......
000020: 01 01 27 0F  27 10 00 1A  28 AC 54 68  69 73 20 69 : ..'.'... (.This i
000030: 73 20 55 44  50 20 74 65  73 74 2E 0A              : s UDP te st..    
==

このデータをベースにして，ポート番号を変更しながら複数のUDPパケットを
生成するようなスクリプト(udp.pl)を書いてみましょう．以下のような感じです．

#!/usr/bin/perl

for ($i = 0; $i < 256; $i++) {
    $n = sprintf("%02X", $i);
    print "--\n";
    print "00 11 22 33  44 55 00 AA  BB CC DD EE  08 00 45 00\n";
    print "00 2E 00 01  00 00 40 11  F7 6A C0 A8  01 02 C0 A8\n";
    print "01 01 7F FF  80 $n 00 1A  28 AC 54 68  69 73 20 69\n";
    print "73 20 55 44  50 20 74 65  73 74 2E 0A\n";
    print "==\n";
}

上の udp.pl は「$n」の部分でポート番号を順番に変更しながらパケット生成
しています．

もしくは，以下のようにフィールド値書き換えで実現してもいいでしょう．

#!/usr/bin/perl

for ($i = 0x8000; $i < 0x8000+256; $i++) {
    print "--\n";
    print "00 11 22 33  44 55 00 AA  BB CC DD EE  08 00 45 00\n";
    print "00 2E 00 01  00 00 40 11  F7 6A C0 A8  01 02 C0 A8\n";
    print "01 01 7F FF  00 00 00 1A  28 AC 54 68  69 73 20 69\n";
    print "73 20 55 44  50 20 74 65  73 74 2E 0A\n";
    print "UDP.DST_PORT: $i\n";
    print "==\n";
}

上の例では「UDP.DST_PORT」によりポート番号を上書き指定しています．

以下で，実際に生成したUDPパケットを確認できます．

% ./udp.pl | pkt-txt2txt

Wiresharkでも確認できます．

% ./udp.pl | pkt-txt2pcap > udp.pcap
% wireshark udp.pcap

以下のようにすることで，生成したUDPを送信することができます．
実際にはチェックサムが変わってきてしまうので，pkt-correct を通すことで
チェックサムを再計算＆再設定して送信できます．

% ./udp.pl | pkt-correct | pkt-send -i rl0

■ UDPのパケットを自作してみる

パケットをゼロから構築したい場合には，以下のようにするといいでしょう．
以下はUDPのパケットを作り上げる例です．

まず，SIZE: によりサイズを指定します．(おおまかでいい)
以下のような感じです．

--
SIZE: 100
==

適当なパラメータでEthernetヘッダを作成します．以下のような感じです．

--
SIZE: 100
ETHERNET.DST_ADDR: FF:FF:FF:FF:FF:FF
ETHERNET.SRC_ADDR: 00:11:22:33:44:55
ETHERNET.TYPE:     0x0800    (IPパケットを指定)
==

上の内容を udp.txt というファイルに保存し，見てみます．
タイプを0x0800(IP)にしたので，空のIPパケットとして解析されます．

% cat udp.txt
--
SIZE: 100
ETHERNET.DST_ADDR: FF:FF:FF:FF:FF:FF
ETHERNET.SRC_ADDR: 00:11:22:33:44:55
ETHERNET.TYPE:     0x0800    (IPパケットを指定)
==
% cat udp.txt | pkt-analyze
-- 1 --
received: 100 bytes    0.000000 Thu Jan  1 09:00:00 1970
00:11:22:33:44:55 -> ff:ff:ff:ff:ff:ff  (type: 0x0800)
IP      head/total size : 0 / 0 bytes
        ID/fragment     : 0x0000 / 0x0000
        TTL/protocol    : 0 / 0
        checksum        : 0x0000
        src/dst addr    : 0.0.0.0 / 0.0.0.0
==

udp.txt にIPヘッダの内容を適当に追加します．
フィールド名は asm_field.c を参照するか，もしくは pkt-recv -a で適当に
出力させることでわかります．

--
SIZE: 100
ETHERNET.DST_ADDR: FF:FF:FF:FF:FF:FF
ETHERNET.SRC_ADDR: 00:11:22:33:44:55
ETHERNET.TYPE:     0x0800
IP.VERSION:      4
IP.HEADER_SIZE: 20
IP.TOTAL_SIZE:  64
IP.TTL:         64
IP.PROTOCOL:    17
IP.SRC_ADDR:    192.168.1.1
IP.DST_ADDR:    192.168.1.2
==

解析して見てみます．
プロトコル番号を17(UDP)にしたので，UDPとして解析されています．

% cat udp.txt | pkt-analyze
-- 1 --
received: 100 bytes    0.000000 Thu Jan  1 09:00:00 1970
00:11:22:33:44:55 -> ff:ff:ff:ff:ff:ff  (type: 0x0800)
IP      head/total size : 20 / 64 bytes
        ID/fragment     : 0x0000 / 0x0000
        TTL/protocol    : 64 / 17
        checksum        : 0x0000
        src/dst addr    : 192.168.1.1 / 192.168.1.2
UDP     total size      : 44 bytes
        src/dst port    : 0 / 0
        length/checksum : 0 / 0x0000
==

udp.txt にUDPヘッダの内容を適当に追加します．
サイズも調整します．

--
SIZE: 78  (「Ethernetヘッダ＋IPヘッダ＋UDP」＝14＋20＋44＝78)
ETHERNET.DST_ADDR: FF:FF:FF:FF:FF:FF
ETHERNET.SRC_ADDR: 00:11:22:33:44:55
ETHERNET.TYPE:     0x0800
IP.VERSION:      4
IP.HEADER_SIZE: 20
IP.TOTAL_SIZE:  64
IP.TTL:         64
IP.PROTOCOL:    17
IP.SRC_ADDR:    192.168.1.1
IP.DST_ADDR:    192.168.1.2
UDP.SRC_PORT:   1000
UDP.DST_PORT:   1001
UDP.SIZE:       44
==

解析して見てみます．

% cat udp.txt | pkt-analyze
-- 1 --
received: 78 bytes    0.000000 Thu Jan  1 09:00:00 1970
00:11:22:33:44:55 -> ff:ff:ff:ff:ff:ff  (type: 0x0800)
IP      head/total size : 20 / 64 bytes
        ID/fragment     : 0x0000 / 0x0000
        TTL/protocol    : 64 / 17
        checksum        : 0x0000
        src/dst addr    : 192.168.1.1 / 192.168.1.2
UDP     total size      : 44 bytes
        src/dst port    : 1000 / 1001
        length/checksum : 44 / 0x0000
==

チェックサム計算をして，整形して保存します．

% cat udp.txt | pkt-correct -a > udp-data.txt

このようにして，パケットを自作することができます．

あとは udp-data.txt をいろいろに編集して使うことができます．
上の例では -a でフィールド値も含めて udp-data.txt を作成していますので，
フィールド値をいろいろに変更して使いたい場合に便利でしょう．

■ おしまい
